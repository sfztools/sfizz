<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Home - Sfizz</title>
		<meta name="author" content="Paul Ferrand">
		<meta name="web-author" content="RedTide">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<!-- Atom Feeds -->
		<link href="./../atom.xml" rel="alternate" title="News"
			type="application/atom+xml" />
		<!-- Favicon Generator Icons -->
		<link rel="apple-touch-icon" sizes="180x180"
			href="./../assets/ico/apple-touch-icon.png">
		<link rel="icon" type="image/png" sizes="32x32" href="./../assets/ico/favicon-32x32.png">
		<link rel="icon" type="image/png" sizes="16x16" href="./../assets/ico/favicon-16x16.png">
		<link rel="manifest" href="./../assets/ico/site.webmanifest">
		<link rel="mask-icon" href="./../assets/ico/safari-pinned-tab.svg"
			color="#5bbad5">
		<link rel="shortcut icon" href="./../assets/ico/favicon.ico">
		<meta name="msapplication-TileColor"
			content="#da532c">
		<meta name="msapplication-config" content="./../assets/ico/browserconfig.xml">
		<meta name="theme-color" content="#ffffff">
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
		<!-- Stylesheets -->
		<link href="./../assets/css/style.min.css"
			rel="stylesheet" media="screen">
		<!-- Font Awesome Icons -->
		<script src="https://kit.fontawesome.com/8d25d19870.js"></script>
	</head>
	<body>
        <div class="container">
		<button onclick="topFunction()" id="scrollButton" title="Go to top">Top</button>
		<a href="#content" class="sr-only">Skip to content</a>
			<nav class="navbar navbar-expand-lg navbar-dark" style="background-color:#222">
				<a class="navbar-brand" href="./../"><img src="./../assets/img/logo.png"
                    width="30" height="30" class="d-inline-block">Sfizz</a>
				<button class="navbar-toggler" type="button" data-toggle="collapse"
					data-target="#navbarContent" aria-controls="navbarContent"
					aria-expanded="false" aria-label="Toggle navigation">
					<span class="navbar-toggler-icon"></span>
				</button>
				<div class="collapse navbar-collapse" id="navbarContent">
					<ul class="navbar-nav mr-auto mt-2 mt-lg-0">
						<li class="nav-item">
							<a class="nav-link" href="./../status"><i class="fas fa-tasks fa-fw"
									aria-hidden="true"></i>&nbsp;Status</a>
						</li>
						<li class="nav-item">
							<a class="nav-link" href="./../downloads"><i class="fas fa-download fa-fw"
									aria-hidden="true"></i>&nbsp;Downloads</a>
						</li>
						<li class="nav-item">
							<a class="nav-link" href="./../contacts"><i class="fas fa-at fa-fw"
									aria-hidden="true"></i>&nbsp;Contacts</a>
						</li>
						<li class="nav-item">
							<a class="nav-link" href="https://sfztools.github.io/"><i class="fas fa-home fa-fw"
									aria-hidden="true"></i>&nbsp;Home</a>
						</li>
					</ul>
				</div>
			</nav>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sfz Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This file contains a pair of RAII helpers that handle some form of lock-free mutex-type protection adapter to audio applications where you have 1 priority thread that should never block and would rather return silence than wait, and another low-priority thread that handles long computations.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsfz_1_1_a_d_s_r_envelope.html">ADSREnvelope</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describe an attack/delay/sustain/release envelope that can produce its coefficient in a blockwise manner for SIMD-type operations.  <a href="classsfz_1_1_a_d_s_r_envelope.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsfz_1_1_atomic_disabler.html">AtomicDisabler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple class to set an atomic to false and automatically set it back to true on destruction.  <a href="classsfz_1_1_atomic_disabler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsfz_1_1_atomic_guard.html">AtomicGuard</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple class to set an atomic to true and automatically set it back to false on destruction.  <a href="classsfz_1_1_atomic_guard.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsfz_1_1_audio_buffer.html">AudioBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to handle a collection of buffers, where each buffer has the same size.  <a href="classsfz_1_1_audio_buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsfz_1_1_audio_span.html">AudioSpan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extension of the concept of spans to multiple channels.  <a href="classsfz_1_1_audio_span.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsfz_1_1_buffer.html">Buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A heap buffer structure that tries to align its beginning and adds a small offset at the end for alignment too.  <a href="classsfz_1_1_buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsfz_1_1_buffer_counter.html">BufferCounter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A buffer counting class that tries to track the memory usage.  <a href="classsfz_1_1_buffer_counter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsfz_1_1_c_c_map.html">CCMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple map that holds ValueType elements at different indices, and can return a default one if not present.  <a href="classsfz_1_1_c_c_map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsfz_1_1_e_g_description.html">EGDescription</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A description for an SFZ envelope generator, with its envelope parameters and possible CC modulation.  <a href="structsfz_1_1_e_g_description.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsfz_1_1_event_envelope.html">EventEnvelope</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes a simple envelope that can be polled in a blockwise manner.  <a href="classsfz_1_1_event_envelope.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsfz_1_1_file_pool.html">FilePool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a singleton-designed class that holds all the preloaded data as well as functions to request new file data and collect the file handles to close after they are read.  <a href="classsfz_1_1_file_pool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsfz_1_1_historical_buffer.html">HistoricalBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A naive circular buffer which is supposed to hold power values and return the average of its content.  <a href="classsfz_1_1_historical_buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsfz_1_1_linear_envelope.html">LinearEnvelope</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes a simple linear envelope.  <a href="classsfz_1_1_linear_envelope.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsfz_1_1_midi_state.html">MidiState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds the current "MIDI state", meaning the known state of all CCs currently, as well as the note velocities that triggered the currently pressed notes.  <a href="classsfz_1_1_midi_state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsfz_1_1_multiplicative_envelope.html">MultiplicativeEnvelope</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes a simple multiplicative envelope.  <a href="classsfz_1_1_multiplicative_envelope.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsfz_1_1_one_pole_filter.html">OnePoleFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of a one pole filter.  <a href="classsfz_1_1_one_pole_filter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsfz_1_1_opcode.html">Opcode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structsfz_1_1_opcode.html" title="Opcode description class; should be very lightweight to use and move around. ">Opcode</a> description class; should be very lightweight to use and move around.  <a href="structsfz_1_1_opcode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsfz_1_1_oversampler.html">Oversampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the internal oversampler in a single function that takes an <a class="el" href="classsfz_1_1_audio_buffer.html" title="A class to handle a collection of buffers, where each buffer has the same size. ">AudioBuffer</a> and oversamples it in another pre-allocated one.  <a href="classsfz_1_1_oversampler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsfz_1_1_range.html">Range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class holds a range with functions to clamp and test if a value is in the range.  <a href="classsfz_1_1_range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsfz_1_1_region.html">Region</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Regions are the basic building blocks for the SFZ parsing and handling code.  <a href="structsfz_1_1_region.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsfz_1_1_synth.html">Synth</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is the core of the sfizz library.  <a href="classsfz_1_1_synth.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsfz_1_1_voice.html">Voice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SFZ voice are the polyphony holders.  <a href="classsfz_1_1_voice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8d1e1f13e28869bb010ca42494d23ca7"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , std::enable_if_t&lt; std::is_integral&lt; ValueType &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a8d1e1f13e28869bb010ca42494d23ca7"><td class="memTemplItemLeft" align="right" valign="top">absl::optional&lt; ValueType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesfz.html#a8d1e1f13e28869bb010ca42494d23ca7">readOpcode</a> (absl::string_view value, const <a class="el" href="classsfz_1_1_range.html">Range</a>&lt; ValueType &gt; &amp;validRange)</td></tr>
<tr class="memdesc:a8d1e1f13e28869bb010ca42494d23ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a value from the sfz file and cast it to the destination parameter along with a proper clamping into range if needed.  <a href="#a8d1e1f13e28869bb010ca42494d23ca7">More...</a><br /></td></tr>
<tr class="separator:a8d1e1f13e28869bb010ca42494d23ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e79b5c1153af2378ddeb5ef1af2e108"><td class="memItemLeft" align="right" valign="top">absl::optional&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesfz.html#a1e79b5c1153af2378ddeb5ef1af2e108">readBooleanFromOpcode</a> (const <a class="el" href="structsfz_1_1_opcode.html">Opcode</a> &amp;opcode)</td></tr>
<tr class="memdesc:a1e79b5c1153af2378ddeb5ef1af2e108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a boolean value from the sfz file and cast it to the destination parameter.  <a href="#a1e79b5c1153af2378ddeb5ef1af2e108">More...</a><br /></td></tr>
<tr class="separator:a1e79b5c1153af2378ddeb5ef1af2e108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83aae00d3fce9c8f65838d7b3a1ee5e9"><td class="memTemplParams" colspan="2">template&lt;class ValueType &gt; </td></tr>
<tr class="memitem:a83aae00d3fce9c8f65838d7b3a1ee5e9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesfz.html#a83aae00d3fce9c8f65838d7b3a1ee5e9">setValueFromOpcode</a> (const <a class="el" href="structsfz_1_1_opcode.html">Opcode</a> &amp;opcode, ValueType &amp;target, const <a class="el" href="classsfz_1_1_range.html">Range</a>&lt; ValueType &gt; &amp;validRange)</td></tr>
<tr class="memdesc:a83aae00d3fce9c8f65838d7b3a1ee5e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a target parameter from an opcode value, with possibly a textual note rather than a number.  <a href="#a83aae00d3fce9c8f65838d7b3a1ee5e9">More...</a><br /></td></tr>
<tr class="separator:a83aae00d3fce9c8f65838d7b3a1ee5e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31aeb210ef9bc2aae030c9979a8a2cc0"><td class="memTemplParams" colspan="2">template&lt;class ValueType &gt; </td></tr>
<tr class="memitem:a31aeb210ef9bc2aae030c9979a8a2cc0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesfz.html#a31aeb210ef9bc2aae030c9979a8a2cc0">setValueFromOpcode</a> (const <a class="el" href="structsfz_1_1_opcode.html">Opcode</a> &amp;opcode, absl::optional&lt; ValueType &gt; &amp;target, const <a class="el" href="classsfz_1_1_range.html">Range</a>&lt; ValueType &gt; &amp;validRange)</td></tr>
<tr class="memdesc:a31aeb210ef9bc2aae030c9979a8a2cc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a target parameter from an opcode value, with possibly a textual note rather than a number.  <a href="#a31aeb210ef9bc2aae030c9979a8a2cc0">More...</a><br /></td></tr>
<tr class="separator:a31aeb210ef9bc2aae030c9979a8a2cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38e52ee55b8e40f517f2a43c57931aa6"><td class="memTemplParams" colspan="2">template&lt;class ValueType &gt; </td></tr>
<tr class="memitem:a38e52ee55b8e40f517f2a43c57931aa6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesfz.html#a38e52ee55b8e40f517f2a43c57931aa6">setRangeEndFromOpcode</a> (const <a class="el" href="structsfz_1_1_opcode.html">Opcode</a> &amp;opcode, <a class="el" href="classsfz_1_1_range.html">Range</a>&lt; ValueType &gt; &amp;target, const <a class="el" href="classsfz_1_1_range.html">Range</a>&lt; ValueType &gt; &amp;validRange)</td></tr>
<tr class="memdesc:a38e52ee55b8e40f517f2a43c57931aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a target end of a range from an opcode value, with possibly a textual note rather than a number.  <a href="#a38e52ee55b8e40f517f2a43c57931aa6">More...</a><br /></td></tr>
<tr class="separator:a38e52ee55b8e40f517f2a43c57931aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a2f75efbbcdb47c66cf32f18bb207ba"><td class="memTemplParams" colspan="2">template&lt;class ValueType &gt; </td></tr>
<tr class="memitem:a6a2f75efbbcdb47c66cf32f18bb207ba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesfz.html#a6a2f75efbbcdb47c66cf32f18bb207ba">setRangeStartFromOpcode</a> (const <a class="el" href="structsfz_1_1_opcode.html">Opcode</a> &amp;opcode, <a class="el" href="classsfz_1_1_range.html">Range</a>&lt; ValueType &gt; &amp;target, const <a class="el" href="classsfz_1_1_range.html">Range</a>&lt; ValueType &gt; &amp;validRange)</td></tr>
<tr class="memdesc:a6a2f75efbbcdb47c66cf32f18bb207ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a target beginning of a range from an opcode value, with possibly a textual note rather than a number.  <a href="#a6a2f75efbbcdb47c66cf32f18bb207ba">More...</a><br /></td></tr>
<tr class="separator:a6a2f75efbbcdb47c66cf32f18bb207ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef36c198066be8bee85b445c483f71a1"><td class="memTemplParams" colspan="2">template&lt;class ValueType &gt; </td></tr>
<tr class="memitem:aef36c198066be8bee85b445c483f71a1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesfz.html#aef36c198066be8bee85b445c483f71a1">setCCPairFromOpcode</a> (const <a class="el" href="structsfz_1_1_opcode.html">Opcode</a> &amp;opcode, absl::optional&lt; CCValuePair &gt; &amp;target, const <a class="el" href="classsfz_1_1_range.html">Range</a>&lt; ValueType &gt; &amp;validRange)</td></tr>
<tr class="memdesc:aef36c198066be8bee85b445c483f71a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a CC modulation parameter from an opcode value.  <a href="#aef36c198066be8bee85b445c483f71a1">More...</a><br /></td></tr>
<tr class="separator:aef36c198066be8bee85b445c483f71a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace381c89be8ea56969614a371b7edae2"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ace381c89be8ea56969614a371b7edae2"><td class="memTemplItemLeft" align="right" valign="top">constexpr float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesfz.html#ace381c89be8ea56969614a371b7edae2">centsFactor</a> (T cents, T centsPerOctave=1200)</td></tr>
<tr class="memdesc:ace381c89be8ea56969614a371b7edae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts cents to a pitch ratio.  <a href="#ace381c89be8ea56969614a371b7edae2">More...</a><br /></td></tr>
<tr class="separator:ace381c89be8ea56969614a371b7edae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b65015c18e6461f96cb9af4e30cdee8"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a9b65015c18e6461f96cb9af4e30cdee8"><td class="memTemplItemLeft" align="right" valign="top">constexpr float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesfz.html#a9b65015c18e6461f96cb9af4e30cdee8">normalizeCC</a> (T ccValue)</td></tr>
<tr class="memdesc:a9b65015c18e6461f96cb9af4e30cdee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize a CC value between (T)0.0 and (T)1.0.  <a href="#a9b65015c18e6461f96cb9af4e30cdee8">More...</a><br /></td></tr>
<tr class="separator:a9b65015c18e6461f96cb9af4e30cdee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd3f3f2641b8065321f00b8e2e3cbec"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a6fd3f3f2641b8065321f00b8e2e3cbec"><td class="memTemplItemLeft" align="right" valign="top">constexpr float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesfz.html#a6fd3f3f2641b8065321f00b8e2e3cbec">normalizeVelocity</a> (T velocity)</td></tr>
<tr class="memdesc:a6fd3f3f2641b8065321f00b8e2e3cbec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize a velocity between (T)0.0 and (T)1.0.  <a href="#a6fd3f3f2641b8065321f00b8e2e3cbec">More...</a><br /></td></tr>
<tr class="separator:a6fd3f3f2641b8065321f00b8e2e3cbec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f49ce61c8d1db977f17efc4ee199bf"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac1f49ce61c8d1db977f17efc4ee199bf"><td class="memTemplItemLeft" align="right" valign="top">constexpr float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesfz.html#ac1f49ce61c8d1db977f17efc4ee199bf">normalizePercents</a> (T percentValue)</td></tr>
<tr class="memdesc:ac1f49ce61c8d1db977f17efc4ee199bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize a percentage between 0 and 1.  <a href="#ac1f49ce61c8d1db977f17efc4ee199bf">More...</a><br /></td></tr>
<tr class="separator:ac1f49ce61c8d1db977f17efc4ee199bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a082ee2dc6715392c07a5f6a5216c537b"><td class="memItemLeft" align="right" valign="top">constexpr float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesfz.html#a082ee2dc6715392c07a5f6a5216c537b">normalizeBend</a> (float bendValue)</td></tr>
<tr class="memdesc:a082ee2dc6715392c07a5f6a5216c537b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize bends between -1 and 1.  <a href="#a082ee2dc6715392c07a5f6a5216c537b">More...</a><br /></td></tr>
<tr class="separator:a082ee2dc6715392c07a5f6a5216c537b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfcbb9f0d7899c187863d5e457a84fca"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:abfcbb9f0d7899c187863d5e457a84fca"><td class="memTemplItemLeft" align="right" valign="top">constexpr float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesfz.html#abfcbb9f0d7899c187863d5e457a84fca">normalizeNegativePercents</a> (T percentValue)</td></tr>
<tr class="memdesc:abfcbb9f0d7899c187863d5e457a84fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize a possibly negative percentage between -1 and 1.  <a href="#abfcbb9f0d7899c187863d5e457a84fca">More...</a><br /></td></tr>
<tr class="separator:abfcbb9f0d7899c187863d5e457a84fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ed5c444b21ac2033875210cdd626ab"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesfz.html#a11ed5c444b21ac2033875210cdd626ab">ccSwitchedValue</a> (const SfzCCArray &amp;ccValues, const absl::optional&lt; CCValuePair &gt; &amp;ccSwitch, float value) noexcept</td></tr>
<tr class="memdesc:a11ed5c444b21ac2033875210cdd626ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a cc switch exists for the value, returns the value with the CC modifier, otherwise returns the value alone.  <a href="#a11ed5c444b21ac2033875210cdd626ab">More...</a><br /></td></tr>
<tr class="separator:a11ed5c444b21ac2033875210cdd626ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc410e944cee93f0c4a0cf44279ebe5d"><td class="memItemLeft" align="right" valign="top">absl::optional&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesfz.html#afc410e944cee93f0c4a0cf44279ebe5d">readNoteValue</a> (const absl::string_view &amp;value)</td></tr>
<tr class="memdesc:afc410e944cee93f0c4a0cf44279ebe5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a note in string to its equivalent midi note number.  <a href="#afc410e944cee93f0c4a0cf44279ebe5d">More...</a><br /></td></tr>
<tr class="separator:afc410e944cee93f0c4a0cf44279ebe5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62f12e86de3f5c188a3a46840ded9030"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesfz.html#a62f12e86de3f5c188a3a46840ded9030">findHeader</a> (absl::string_view &amp;source, absl::string_view &amp;header, absl::string_view &amp;members)</td></tr>
<tr class="memdesc:a62f12e86de3f5c188a3a46840ded9030"><td class="mdescLeft">&#160;</td><td class="mdescRight">From a source view, find the next sfz header and its members and return them, while updating the source by removing this header and members from the beginning.  <a href="#a62f12e86de3f5c188a3a46840ded9030">More...</a><br /></td></tr>
<tr class="separator:a62f12e86de3f5c188a3a46840ded9030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fd5bcf4ef8db620c9ce8dd153637e80"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesfz.html#a2fd5bcf4ef8db620c9ce8dd153637e80">findOpcode</a> (absl::string_view &amp;source, absl::string_view &amp;opcode, absl::string_view &amp;value)</td></tr>
<tr class="memdesc:a2fd5bcf4ef8db620c9ce8dd153637e80"><td class="mdescLeft">&#160;</td><td class="mdescRight">From a source view, find the next sfz member opcode and its value.  <a href="#a2fd5bcf4ef8db620c9ce8dd153637e80">More...</a><br /></td></tr>
<tr class="separator:a2fd5bcf4ef8db620c9ce8dd153637e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0154fe33ffa4619bd53939364a8cbe27"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesfz.html#a0154fe33ffa4619bd53939364a8cbe27">findDefine</a> (absl::string_view line, absl::string_view &amp;variable, absl::string_view &amp;value)</td></tr>
<tr class="memdesc:a0154fe33ffa4619bd53939364a8cbe27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an SFZ #define statement on a line and return the variable and value as views.  <a href="#a0154fe33ffa4619bd53939364a8cbe27">More...</a><br /></td></tr>
<tr class="separator:a0154fe33ffa4619bd53939364a8cbe27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad493a0ef0d896c138a235f3b1d63d136"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesfz.html#ad493a0ef0d896c138a235f3b1d63d136">findInclude</a> (absl::string_view line, std::string &amp;path)</td></tr>
<tr class="memdesc:ad493a0ef0d896c138a235f3b1d63d136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an SFZ #include statement on a line and return included path.  <a href="#ad493a0ef0d896c138a235f3b1d63d136">More...</a><br /></td></tr>
<tr class="separator:ad493a0ef0d896c138a235f3b1d63d136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91425402d9ab9ea06c43f2b50deceff7"><td class="memTemplParams" colspan="2">template&lt;class T , bool SIMD = SIMDConfig::readInterleaved&gt; </td></tr>
<tr class="memitem:a91425402d9ab9ea06c43f2b50deceff7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesfz.html#a91425402d9ab9ea06c43f2b50deceff7">readInterleaved</a> (absl::Span&lt; const T &gt; input, absl::Span&lt; T &gt; outputLeft, absl::Span&lt; T &gt; outputRight) noexcept</td></tr>
<tr class="memdesc:a91425402d9ab9ea06c43f2b50deceff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read interleaved stereo data from a buffer and separate it in a left/right pair of buffers.  <a href="#a91425402d9ab9ea06c43f2b50deceff7">More...</a><br /></td></tr>
<tr class="separator:a91425402d9ab9ea06c43f2b50deceff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187a894c21d22a6571c6fe2a9394228f"><td class="memTemplParams" colspan="2">template&lt;class T , bool SIMD = SIMDConfig::writeInterleaved&gt; </td></tr>
<tr class="memitem:a187a894c21d22a6571c6fe2a9394228f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesfz.html#a187a894c21d22a6571c6fe2a9394228f">writeInterleaved</a> (absl::Span&lt; const T &gt; inputLeft, absl::Span&lt; const T &gt; inputRight, absl::Span&lt; T &gt; output) noexcept</td></tr>
<tr class="memdesc:a187a894c21d22a6571c6fe2a9394228f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a pair of left and right stereo input into a single buffer interleaved.  <a href="#a187a894c21d22a6571c6fe2a9394228f">More...</a><br /></td></tr>
<tr class="separator:a187a894c21d22a6571c6fe2a9394228f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a5601af5f6d2113fdda2394fd7b00a0"><td class="memTemplParams" colspan="2">template&lt;class T , bool SIMD = SIMDConfig::fill&gt; </td></tr>
<tr class="memitem:a1a5601af5f6d2113fdda2394fd7b00a0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesfz.html#a1a5601af5f6d2113fdda2394fd7b00a0">fill</a> (absl::Span&lt; T &gt; output, T value) noexcept</td></tr>
<tr class="memdesc:a1a5601af5f6d2113fdda2394fd7b00a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a buffer with a value; comparable to std::fill in essence.  <a href="#a1a5601af5f6d2113fdda2394fd7b00a0">More...</a><br /></td></tr>
<tr class="separator:a1a5601af5f6d2113fdda2394fd7b00a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb3fd29a957ebca6df035ba30e155f35"><td class="memTemplParams" colspan="2">template&lt;class Type , bool SIMD = SIMDConfig::mathfuns&gt; </td></tr>
<tr class="memitem:acb3fd29a957ebca6df035ba30e155f35"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesfz.html#acb3fd29a957ebca6df035ba30e155f35">exp</a> (absl::Span&lt; const Type &gt; input, absl::Span&lt; Type &gt; output) noexcept</td></tr>
<tr class="memdesc:acb3fd29a957ebca6df035ba30e155f35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exp math function.  <a href="#acb3fd29a957ebca6df035ba30e155f35">More...</a><br /></td></tr>
<tr class="separator:acb3fd29a957ebca6df035ba30e155f35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc574b28974cd1bd8af7dee2c2cdb24f"><td class="memTemplParams" colspan="2">template&lt;class Type , bool SIMD = SIMDConfig::mathfuns&gt; </td></tr>
<tr class="memitem:adc574b28974cd1bd8af7dee2c2cdb24f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesfz.html#adc574b28974cd1bd8af7dee2c2cdb24f">log</a> (absl::Span&lt; const Type &gt; input, absl::Span&lt; Type &gt; output) noexcept</td></tr>
<tr class="memdesc:adc574b28974cd1bd8af7dee2c2cdb24f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log math function.  <a href="#adc574b28974cd1bd8af7dee2c2cdb24f">More...</a><br /></td></tr>
<tr class="separator:adc574b28974cd1bd8af7dee2c2cdb24f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c69c4723a06f6e692ddfee094420fb"><td class="memTemplParams" colspan="2">template&lt;class Type , bool SIMD = SIMDConfig::mathfuns&gt; </td></tr>
<tr class="memitem:a92c69c4723a06f6e692ddfee094420fb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesfz.html#a92c69c4723a06f6e692ddfee094420fb">sin</a> (absl::Span&lt; const Type &gt; input, absl::Span&lt; Type &gt; output) noexcept</td></tr>
<tr class="memdesc:a92c69c4723a06f6e692ddfee094420fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">sin math function  <a href="#a92c69c4723a06f6e692ddfee094420fb">More...</a><br /></td></tr>
<tr class="separator:a92c69c4723a06f6e692ddfee094420fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a921cd12917ee9b0eb2a60b5d50f1881c"><td class="memTemplParams" colspan="2">template&lt;class Type , bool SIMD = SIMDConfig::mathfuns&gt; </td></tr>
<tr class="memitem:a921cd12917ee9b0eb2a60b5d50f1881c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesfz.html#a921cd12917ee9b0eb2a60b5d50f1881c">cos</a> (absl::Span&lt; const Type &gt; input, absl::Span&lt; Type &gt; output) noexcept</td></tr>
<tr class="memdesc:a921cd12917ee9b0eb2a60b5d50f1881c"><td class="mdescLeft">&#160;</td><td class="mdescRight">cos math function  <a href="#a921cd12917ee9b0eb2a60b5d50f1881c">More...</a><br /></td></tr>
<tr class="separator:a921cd12917ee9b0eb2a60b5d50f1881c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c7883329dc3ff5455577487a444b5e8"><td class="memTemplParams" colspan="2">template&lt;class T , bool SIMD = SIMDConfig::saturatingSFZIndex&gt; </td></tr>
<tr class="memitem:a3c7883329dc3ff5455577487a444b5e8"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesfz.html#a3c7883329dc3ff5455577487a444b5e8">saturatingSFZIndex</a> (absl::Span&lt; const T &gt; jumps, absl::Span&lt; T &gt; leftCoeffs, absl::Span&lt; T &gt; rightCoeffs, absl::Span&lt; int &gt; indices, T floatIndex, T loopEnd) noexcept</td></tr>
<tr class="memdesc:a3c7883329dc3ff5455577487a444b5e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an integer index and 2 float coefficients corresponding to the linear interpolation procedure.  <a href="#a3c7883329dc3ff5455577487a444b5e8">More...</a><br /></td></tr>
<tr class="separator:a3c7883329dc3ff5455577487a444b5e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6a4868395156fa7a5cd3a12277e3cab"><td class="memTemplParams" colspan="2">template&lt;class T , bool SIMD = SIMDConfig::loopingSFZIndex&gt; </td></tr>
<tr class="memitem:af6a4868395156fa7a5cd3a12277e3cab"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesfz.html#af6a4868395156fa7a5cd3a12277e3cab">loopingSFZIndex</a> (absl::Span&lt; const T &gt; jumps, absl::Span&lt; T &gt; leftCoeffs, absl::Span&lt; T &gt; rightCoeffs, absl::Span&lt; int &gt; indices, T floatIndex, T loopEnd, T loopStart) noexcept</td></tr>
<tr class="memdesc:af6a4868395156fa7a5cd3a12277e3cab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an integer index and 2 float coefficients corresponding to the linear interpolation procedure.  <a href="#af6a4868395156fa7a5cd3a12277e3cab">More...</a><br /></td></tr>
<tr class="separator:af6a4868395156fa7a5cd3a12277e3cab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26799677f2d57c4714d2bc514a938b58"><td class="memTemplParams" colspan="2">template&lt;class T , bool SIMD = SIMDConfig::gain&gt; </td></tr>
<tr class="memitem:a26799677f2d57c4714d2bc514a938b58"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesfz.html#a26799677f2d57c4714d2bc514a938b58">applyGain</a> (T gain, absl::Span&lt; const T &gt; input, absl::Span&lt; T &gt; output) noexcept</td></tr>
<tr class="memdesc:a26799677f2d57c4714d2bc514a938b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a scalar gain to the input.  <a href="#a26799677f2d57c4714d2bc514a938b58">More...</a><br /></td></tr>
<tr class="separator:a26799677f2d57c4714d2bc514a938b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e3b072204d32b7da439d392cbd2901f"><td class="memTemplParams" colspan="2">template&lt;class T , bool SIMD = SIMDConfig::gain&gt; </td></tr>
<tr class="memitem:a2e3b072204d32b7da439d392cbd2901f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesfz.html#a2e3b072204d32b7da439d392cbd2901f">applyGain</a> (absl::Span&lt; const T &gt; gain, absl::Span&lt; const T &gt; input, absl::Span&lt; T &gt; output) noexcept</td></tr>
<tr class="memdesc:a2e3b072204d32b7da439d392cbd2901f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a vector gain to an input stap.  <a href="#a2e3b072204d32b7da439d392cbd2901f">More...</a><br /></td></tr>
<tr class="separator:a2e3b072204d32b7da439d392cbd2901f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a732911d2f0a67e80de4799cf480189c1"><td class="memTemplParams" colspan="2">template&lt;class T , bool SIMD = SIMDConfig::gain&gt; </td></tr>
<tr class="memitem:a732911d2f0a67e80de4799cf480189c1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesfz.html#a732911d2f0a67e80de4799cf480189c1">applyGain</a> (T gain, absl::Span&lt; T &gt; output) noexcept</td></tr>
<tr class="memdesc:a732911d2f0a67e80de4799cf480189c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a scalar gain in-place on a span.  <a href="#a732911d2f0a67e80de4799cf480189c1">More...</a><br /></td></tr>
<tr class="separator:a732911d2f0a67e80de4799cf480189c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de51e21a6941c416de0156d5c270f77"><td class="memTemplParams" colspan="2">template&lt;class T , bool SIMD = SIMDConfig::gain&gt; </td></tr>
<tr class="memitem:a4de51e21a6941c416de0156d5c270f77"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesfz.html#a4de51e21a6941c416de0156d5c270f77">applyGain</a> (absl::Span&lt; const T &gt; gain, absl::Span&lt; T &gt; output) noexcept</td></tr>
<tr class="memdesc:a4de51e21a6941c416de0156d5c270f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a vector gain in-place on a span.  <a href="#a4de51e21a6941c416de0156d5c270f77">More...</a><br /></td></tr>
<tr class="separator:a4de51e21a6941c416de0156d5c270f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add0737429e53441b7180f723e157442f"><td class="memTemplParams" colspan="2">template&lt;class T , bool SIMD = SIMDConfig::divide&gt; </td></tr>
<tr class="memitem:add0737429e53441b7180f723e157442f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesfz.html#add0737429e53441b7180f723e157442f">divide</a> (absl::Span&lt; const T &gt; input, absl::Span&lt; const T &gt; divisor, absl::Span&lt; T &gt; output) noexcept</td></tr>
<tr class="memdesc:add0737429e53441b7180f723e157442f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide a vector by another vector.  <a href="#add0737429e53441b7180f723e157442f">More...</a><br /></td></tr>
<tr class="separator:add0737429e53441b7180f723e157442f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9b2f81370eed27891f98fe86e82ee1"><td class="memTemplParams" colspan="2">template&lt;class T , bool SIMD = SIMDConfig::divide&gt; </td></tr>
<tr class="memitem:abe9b2f81370eed27891f98fe86e82ee1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesfz.html#abe9b2f81370eed27891f98fe86e82ee1">divide</a> (absl::Span&lt; T &gt; output, absl::Span&lt; const T &gt; divisor) noexcept</td></tr>
<tr class="memdesc:abe9b2f81370eed27891f98fe86e82ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide a vector by another in place.  <a href="#abe9b2f81370eed27891f98fe86e82ee1">More...</a><br /></td></tr>
<tr class="separator:abe9b2f81370eed27891f98fe86e82ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc467c5a4f960d8a8afa9516e4020c5e"><td class="memTemplParams" colspan="2">template&lt;class T , bool SIMD = SIMDConfig::multiplyAdd&gt; </td></tr>
<tr class="memitem:afc467c5a4f960d8a8afa9516e4020c5e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesfz.html#afc467c5a4f960d8a8afa9516e4020c5e">multiplyAdd</a> (absl::Span&lt; const T &gt; gain, absl::Span&lt; const T &gt; input, absl::Span&lt; T &gt; output) noexcept</td></tr>
<tr class="memdesc:afc467c5a4f960d8a8afa9516e4020c5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a gain to the input and add it on the output.  <a href="#afc467c5a4f960d8a8afa9516e4020c5e">More...</a><br /></td></tr>
<tr class="separator:afc467c5a4f960d8a8afa9516e4020c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a856b9e5f41439a7443e3fb6e010f8d13"><td class="memTemplParams" colspan="2">template&lt;class T , bool SIMD = SIMDConfig::linearRamp&gt; </td></tr>
<tr class="memitem:a856b9e5f41439a7443e3fb6e010f8d13"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesfz.html#a856b9e5f41439a7443e3fb6e010f8d13">linearRamp</a> (absl::Span&lt; T &gt; output, T start, T step) noexcept</td></tr>
<tr class="memdesc:a856b9e5f41439a7443e3fb6e010f8d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a linear ramp blockwise between 2 values.  <a href="#a856b9e5f41439a7443e3fb6e010f8d13">More...</a><br /></td></tr>
<tr class="separator:a856b9e5f41439a7443e3fb6e010f8d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9103c48dd4d2a8339524f8f5d4136fa"><td class="memTemplParams" colspan="2">template&lt;class T , bool SIMD = SIMDConfig::multiplicativeRamp&gt; </td></tr>
<tr class="memitem:ae9103c48dd4d2a8339524f8f5d4136fa"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesfz.html#ae9103c48dd4d2a8339524f8f5d4136fa">multiplicativeRamp</a> (absl::Span&lt; T &gt; output, T start, T step) noexcept</td></tr>
<tr class="memdesc:ae9103c48dd4d2a8339524f8f5d4136fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a multiplicative ramp blockwise between 2 values.  <a href="#ae9103c48dd4d2a8339524f8f5d4136fa">More...</a><br /></td></tr>
<tr class="separator:ae9103c48dd4d2a8339524f8f5d4136fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0acbcd13727eee5b84f4a7e92377e40"><td class="memTemplParams" colspan="2">template&lt;class T , bool SIMD = SIMDConfig::add&gt; </td></tr>
<tr class="memitem:ad0acbcd13727eee5b84f4a7e92377e40"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesfz.html#ad0acbcd13727eee5b84f4a7e92377e40">add</a> (absl::Span&lt; const T &gt; input, absl::Span&lt; T &gt; output) noexcept</td></tr>
<tr class="memdesc:ad0acbcd13727eee5b84f4a7e92377e40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an input span to the output span.  <a href="#ad0acbcd13727eee5b84f4a7e92377e40">More...</a><br /></td></tr>
<tr class="separator:ad0acbcd13727eee5b84f4a7e92377e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a671c6bbf8866dbeac68ed3b887a705a5"><td class="memTemplParams" colspan="2">template&lt;class T , bool SIMD = SIMDConfig::subtract&gt; </td></tr>
<tr class="memitem:a671c6bbf8866dbeac68ed3b887a705a5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesfz.html#a671c6bbf8866dbeac68ed3b887a705a5">subtract</a> (const T value, absl::Span&lt; T &gt; output) noexcept</td></tr>
<tr class="memdesc:a671c6bbf8866dbeac68ed3b887a705a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract a value from a span.  <a href="#a671c6bbf8866dbeac68ed3b887a705a5">More...</a><br /></td></tr>
<tr class="separator:a671c6bbf8866dbeac68ed3b887a705a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb0d4e00d9e7d95051a90753331f2c53"><td class="memTemplParams" colspan="2">template&lt;class T , bool SIMD = SIMDConfig::subtract&gt; </td></tr>
<tr class="memitem:acb0d4e00d9e7d95051a90753331f2c53"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesfz.html#acb0d4e00d9e7d95051a90753331f2c53">subtract</a> (absl::Span&lt; const T &gt; input, absl::Span&lt; T &gt; output) noexcept</td></tr>
<tr class="memdesc:acb0d4e00d9e7d95051a90753331f2c53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract a span from another span.  <a href="#acb0d4e00d9e7d95051a90753331f2c53">More...</a><br /></td></tr>
<tr class="separator:acb0d4e00d9e7d95051a90753331f2c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f98787f6ed2987d28ffdc0ca5bdc4a"><td class="memTemplParams" colspan="2">template&lt;class T , bool SIMD = SIMDConfig::copy&gt; </td></tr>
<tr class="memitem:af3f98787f6ed2987d28ffdc0ca5bdc4a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesfz.html#af3f98787f6ed2987d28ffdc0ca5bdc4a">copy</a> (absl::Span&lt; const T &gt; input, absl::Span&lt; T &gt; output) noexcept</td></tr>
<tr class="memdesc:af3f98787f6ed2987d28ffdc0ca5bdc4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a span in another.  <a href="#af3f98787f6ed2987d28ffdc0ca5bdc4a">More...</a><br /></td></tr>
<tr class="separator:af3f98787f6ed2987d28ffdc0ca5bdc4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e5453bbc1c786fad5635026eebeaded"><td class="memTemplParams" colspan="2">template&lt;class T , bool SIMD = SIMDConfig::pan&gt; </td></tr>
<tr class="memitem:a3e5453bbc1c786fad5635026eebeaded"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesfz.html#a3e5453bbc1c786fad5635026eebeaded">pan</a> (absl::Span&lt; const T &gt; panEnvelope, absl::Span&lt; T &gt; leftBuffer, absl::Span&lt; T &gt; rightBuffer) noexcept</td></tr>
<tr class="memdesc:a3e5453bbc1c786fad5635026eebeaded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pans a mono signal left or right.  <a href="#a3e5453bbc1c786fad5635026eebeaded">More...</a><br /></td></tr>
<tr class="separator:a3e5453bbc1c786fad5635026eebeaded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a699ab4ea2fc4d6179cbd6c4dd9a2f07b"><td class="memTemplParams" colspan="2">template&lt;class T , bool SIMD = SIMDConfig::mean&gt; </td></tr>
<tr class="memitem:a699ab4ea2fc4d6179cbd6c4dd9a2f07b"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesfz.html#a699ab4ea2fc4d6179cbd6c4dd9a2f07b">mean</a> (absl::Span&lt; const T &gt; vector) noexcept</td></tr>
<tr class="memdesc:a699ab4ea2fc4d6179cbd6c4dd9a2f07b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the mean of a span.  <a href="#a699ab4ea2fc4d6179cbd6c4dd9a2f07b">More...</a><br /></td></tr>
<tr class="separator:a699ab4ea2fc4d6179cbd6c4dd9a2f07b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b3086cab227e08d1b22a4e385388127"><td class="memTemplParams" colspan="2">template&lt;class T , bool SIMD = SIMDConfig::meanSquared&gt; </td></tr>
<tr class="memitem:a4b3086cab227e08d1b22a4e385388127"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesfz.html#a4b3086cab227e08d1b22a4e385388127">meanSquared</a> (absl::Span&lt; const T &gt; vector) noexcept</td></tr>
<tr class="memdesc:a4b3086cab227e08d1b22a4e385388127"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the mean squared of a span.  <a href="#a4b3086cab227e08d1b22a4e385388127">More...</a><br /></td></tr>
<tr class="separator:a4b3086cab227e08d1b22a4e385388127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d68cfdcf6c011ab2b27841b2f37a33a"><td class="memTemplParams" colspan="2">template&lt;class T , bool SIMD = SIMDConfig::cumsum&gt; </td></tr>
<tr class="memitem:a7d68cfdcf6c011ab2b27841b2f37a33a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesfz.html#a7d68cfdcf6c011ab2b27841b2f37a33a">cumsum</a> (absl::Span&lt; const T &gt; input, absl::Span&lt; T &gt; output) noexcept</td></tr>
<tr class="memdesc:a7d68cfdcf6c011ab2b27841b2f37a33a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cumulative sum of a span.  <a href="#a7d68cfdcf6c011ab2b27841b2f37a33a">More...</a><br /></td></tr>
<tr class="separator:a7d68cfdcf6c011ab2b27841b2f37a33a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486b854fada90cb158ee8391466d42a7"><td class="memTemplParams" colspan="2">template&lt;class T , bool SIMD = SIMDConfig::sfzInterpolationCast&gt; </td></tr>
<tr class="memitem:a486b854fada90cb158ee8391466d42a7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesfz.html#a486b854fada90cb158ee8391466d42a7">sfzInterpolationCast</a> (absl::Span&lt; const T &gt; floatJumps, absl::Span&lt; int &gt; jumps, absl::Span&lt; T &gt; leftCoeffs, absl::Span&lt; T &gt; rightCoeffs) noexcept</td></tr>
<tr class="memdesc:a486b854fada90cb158ee8391466d42a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the linear interpolation coefficients for a floating point index and extracts the integer index of the elements to interpolate.  <a href="#a486b854fada90cb158ee8391466d42a7">More...</a><br /></td></tr>
<tr class="separator:a486b854fada90cb158ee8391466d42a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea56d9a29c3d47631dfe237d7041d382"><td class="memTemplParams" colspan="2">template&lt;class T , bool SIMD = SIMDConfig::diff&gt; </td></tr>
<tr class="memitem:aea56d9a29c3d47631dfe237d7041d382"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesfz.html#aea56d9a29c3d47631dfe237d7041d382">diff</a> (absl::Span&lt; const T &gt; input, absl::Span&lt; T &gt; output) noexcept</td></tr>
<tr class="memdesc:aea56d9a29c3d47631dfe237d7041d382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the differential of a span (successive differences).  <a href="#aea56d9a29c3d47631dfe237d7041d382">More...</a><br /></td></tr>
<tr class="separator:aea56d9a29c3d47631dfe237d7041d382"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file contains a pair of RAII helpers that handle some form of lock-free mutex-type protection adapter to audio applications where you have 1 priority thread that should never block and would rather return silence than wait, and another low-priority thread that handles long computations. </p>
<div class="fragment"><div class="line"><span class="comment">// Somewhere in a class...</span></div><div class="line">std::atomic&lt;bool&gt; canEnterCallback;</div><div class="line">std::atomic&lt;bool&gt; inCallback;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> functionThatSuspendsCallback()</div><div class="line">{</div><div class="line">    AtomicDisabler callbackDisabler { canEnterCallback };</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (inCallback) {</div><div class="line">        std::this_thread::sleep_for(1ms);</div><div class="line">    }</div><div class="line"></div><div class="line">       <span class="comment">// Do your thing.</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> callback(<span class="keywordtype">int</span> samplesPerBlock) noexcept</div><div class="line">{</div><div class="line">    AtomicGuard callbackGuard { inCallback };</div><div class="line">    <span class="keywordflow">if</span> (!canEnterCallback)</div><div class="line">        <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">       <span class="comment">// Do your thing.</span></div><div class="line">}</div></div><!-- fragment --><p> There are probably many ways to improve these and probably even debug them. The spinlocking itself could be integrated in the constructor, although the check for return in the callback could not. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ad0acbcd13727eee5b84f4a7e92377e40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0acbcd13727eee5b84f4a7e92377e40">&#9670;&nbsp;</a></span>add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool SIMD = SIMDConfig::add&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sfz::add </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const T &gt;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an input span to the output span. </p>
<p>The output size will be the minimum of the gain span, input span and output span sizes.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the underlying type </td></tr>
    <tr><td class="paramname">SIMD</td><td>use the SIMD version or the scalar version </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td></td></tr>
    <tr><td class="paramname">output</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26799677f2d57c4714d2bc514a938b58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26799677f2d57c4714d2bc514a938b58">&#9670;&nbsp;</a></span>applyGain() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool SIMD = SIMDConfig::gain&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sfz::applyGain </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>gain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const T &gt;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a scalar gain to the input. </p>
<p>The output size will be the minimum of the input span and output span size.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the underlying type </td></tr>
    <tr><td class="paramname">SIMD</td><td>use the SIMD version or the scalar version </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gain</td><td>the gain to apply </td></tr>
    <tr><td class="paramname">input</td><td></td></tr>
    <tr><td class="paramname">output</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e3b072204d32b7da439d392cbd2901f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e3b072204d32b7da439d392cbd2901f">&#9670;&nbsp;</a></span>applyGain() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool SIMD = SIMDConfig::gain&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sfz::applyGain </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const T &gt;&#160;</td>
          <td class="paramname"><em>gain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const T &gt;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a vector gain to an input stap. </p>
<p>The output size will be the minimum of the gain, input span and output span size.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the underlying type </td></tr>
    <tr><td class="paramname">SIMD</td><td>use the SIMD version or the scalar version </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gain</td><td></td></tr>
    <tr><td class="paramname">input</td><td></td></tr>
    <tr><td class="paramname">output</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a732911d2f0a67e80de4799cf480189c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a732911d2f0a67e80de4799cf480189c1">&#9670;&nbsp;</a></span>applyGain() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool SIMD = SIMDConfig::gain&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sfz::applyGain </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>gain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a scalar gain in-place on a span. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the underlying type </td></tr>
    <tr><td class="paramname">SIMD</td><td>use the SIMD version or the scalar version </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gain</td><td></td></tr>
    <tr><td class="paramname">output</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4de51e21a6941c416de0156d5c270f77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4de51e21a6941c416de0156d5c270f77">&#9670;&nbsp;</a></span>applyGain() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool SIMD = SIMDConfig::gain&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sfz::applyGain </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const T &gt;&#160;</td>
          <td class="paramname"><em>gain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a vector gain in-place on a span. </p>
<p>The output size will be the minimum of the gain span and output span size.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the underlying type </td></tr>
    <tr><td class="paramname">SIMD</td><td>use the SIMD version or the scalar version </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gain</td><td></td></tr>
    <tr><td class="paramname">output</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11ed5c444b21ac2033875210cdd626ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11ed5c444b21ac2033875210cdd626ab">&#9670;&nbsp;</a></span>ccSwitchedValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float sfz::ccSwitchedValue </td>
          <td>(</td>
          <td class="paramtype">const SfzCCArray &amp;&#160;</td>
          <td class="paramname"><em>ccValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const absl::optional&lt; CCValuePair &gt; &amp;&#160;</td>
          <td class="paramname"><em>ccSwitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If a cc switch exists for the value, returns the value with the CC modifier, otherwise returns the value alone. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ccValues</td><td></td></tr>
    <tr><td class="paramname">ccSwitch</td><td></td></tr>
    <tr><td class="paramname">value</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>float </dd></dl>

</div>
</div>
<a id="ace381c89be8ea56969614a371b7edae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace381c89be8ea56969614a371b7edae2">&#9670;&nbsp;</a></span>centsFactor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr float sfz::centsFactor </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>cents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>centsPerOctave</em> = <code>1200</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts cents to a pitch ratio. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cents</td><td></td></tr>
    <tr><td class="paramname">centsPerOctave</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>constexpr float </dd></dl>

</div>
</div>
<a id="af3f98787f6ed2987d28ffdc0ca5bdc4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3f98787f6ed2987d28ffdc0ca5bdc4a">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool SIMD = SIMDConfig::copy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sfz::copy </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const T &gt;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy a span in another. </p>
<p>The output size will be the minimum of the input span and output span sizes.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the underlying type </td></tr>
    <tr><td class="paramname">SIMD</td><td>use the SIMD version or the scalar version </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td></td></tr>
    <tr><td class="paramname">output</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a921cd12917ee9b0eb2a60b5d50f1881c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a921cd12917ee9b0eb2a60b5d50f1881c">&#9670;&nbsp;</a></span>cos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , bool SIMD = SIMDConfig::mathfuns&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sfz::cos </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const Type &gt;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; Type &gt;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>cos math function </p>
<p>The output size will be the minimum of the input span and output span size.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the underlying type </td></tr>
    <tr><td class="paramname">SIMD</td><td>use the SIMD version or the scalar version </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td></td></tr>
    <tr><td class="paramname">output</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d68cfdcf6c011ab2b27841b2f37a33a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d68cfdcf6c011ab2b27841b2f37a33a">&#9670;&nbsp;</a></span>cumsum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool SIMD = SIMDConfig::cumsum&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sfz::cumsum </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const T &gt;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the cumulative sum of a span. </p>
<p>The first output is the same as the first input.</p>
<p>The output size will be the minimum of the input span and output span sizes.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the underlying type </td></tr>
    <tr><td class="paramname">SIMD</td><td>use the SIMD version or the scalar version </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T </dd></dl>

</div>
</div>
<a id="aea56d9a29c3d47631dfe237d7041d382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea56d9a29c3d47631dfe237d7041d382">&#9670;&nbsp;</a></span>diff()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool SIMD = SIMDConfig::diff&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sfz::diff </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const T &gt;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the differential of a span (successive differences). </p>
<p>The first output is the same as the first input.</p>
<p>The output size will be the minimum of the input span and output span sizes.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the underlying type </td></tr>
    <tr><td class="paramname">SIMD</td><td>use the SIMD version or the scalar version </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T </dd></dl>

</div>
</div>
<a id="add0737429e53441b7180f723e157442f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add0737429e53441b7180f723e157442f">&#9670;&nbsp;</a></span>divide() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool SIMD = SIMDConfig::divide&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sfz::divide </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const T &gt;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const T &gt;&#160;</td>
          <td class="paramname"><em>divisor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divide a vector by another vector. </p>
<p>The output size will be the minimum of the divisor, input span and output span size.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the underlying type </td></tr>
    <tr><td class="paramname">SIMD</td><td>use the SIMD version or the scalar version </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td></td></tr>
    <tr><td class="paramname">divisor</td><td></td></tr>
    <tr><td class="paramname">output</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe9b2f81370eed27891f98fe86e82ee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe9b2f81370eed27891f98fe86e82ee1">&#9670;&nbsp;</a></span>divide() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool SIMD = SIMDConfig::divide&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sfz::divide </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const T &gt;&#160;</td>
          <td class="paramname"><em>divisor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divide a vector by another in place. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the underlying type </td></tr>
    <tr><td class="paramname">SIMD</td><td>use the SIMD version or the scalar version </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td></td></tr>
    <tr><td class="paramname">divisor</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb3fd29a957ebca6df035ba30e155f35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb3fd29a957ebca6df035ba30e155f35">&#9670;&nbsp;</a></span>exp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , bool SIMD = SIMDConfig::mathfuns&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sfz::exp </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const Type &gt;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; Type &gt;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exp math function. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the underlying type </td></tr>
    <tr><td class="paramname">SIMD</td><td>use the SIMD version or the scalar version </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td></td></tr>
    <tr><td class="paramname">output</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1a5601af5f6d2113fdda2394fd7b00a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a5601af5f6d2113fdda2394fd7b00a0">&#9670;&nbsp;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool SIMD = SIMDConfig::fill&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sfz::fill </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill a buffer with a value; comparable to std::fill in essence. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the underlying type </td></tr>
    <tr><td class="paramname">SIMD</td><td>use the SIMD version or the scalar version </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td></td></tr>
    <tr><td class="paramname">value</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0154fe33ffa4619bd53939364a8cbe27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0154fe33ffa4619bd53939364a8cbe27">&#9670;&nbsp;</a></span>findDefine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sfz::findDefine </td>
          <td>(</td>
          <td class="paramtype">absl::string_view&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::string_view &amp;&#160;</td>
          <td class="paramname"><em>variable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::string_view &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find an SFZ #define statement on a line and return the variable and value as views. </p>
<p>This function assums that there is a single define per line and that the variable and value are separated by whitespace. The output parameters are set only if the method returns true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">line</td><td>The source line </td></tr>
    <tr><td class="paramname">variable</td><td>An output view on the define variable </td></tr>
    <tr><td class="paramname">value</td><td>An output view on the define value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If a define was found </dd>
<dd>
false </dd></dl>

</div>
</div>
<a id="a62f12e86de3f5c188a3a46840ded9030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62f12e86de3f5c188a3a46840ded9030">&#9670;&nbsp;</a></span>findHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sfz::findHeader </td>
          <td>(</td>
          <td class="paramtype">absl::string_view &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::string_view &amp;&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::string_view &amp;&#160;</td>
          <td class="paramname"><em>members</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>From a source view, find the next sfz header and its members and return them, while updating the source by removing this header and members from the beginning. </p>
<p>The function "consumes" the header and its members from the source if found.</p>
<p>No check is made to see if the header is "valid" in the sfz sense. The output parameters are set only if the method returns true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A source view; can be updated and shortened </td></tr>
    <tr><td class="paramname">header</td><td>An output view on the header, without the &lt;&gt; </td></tr>
    <tr><td class="paramname">members</td><td>An output view on the members, untrimmed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a header was found </dd>
<dd>
false otherwise </dd></dl>

</div>
</div>
<a id="ad493a0ef0d896c138a235f3b1d63d136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad493a0ef0d896c138a235f3b1d63d136">&#9670;&nbsp;</a></span>findInclude()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sfz::findInclude </td>
          <td>(</td>
          <td class="paramtype">absl::string_view&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find an SFZ #include statement on a line and return included path. </p>
<p>This function assums that there is a single include per line and that the include path is within quotes. The output parameter is set only if the method returns true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">line</td><td>The source line </td></tr>
    <tr><td class="paramname">path</td><td>The path, if found </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If an include was found </dd>
<dd>
false </dd></dl>

</div>
</div>
<a id="a2fd5bcf4ef8db620c9ce8dd153637e80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fd5bcf4ef8db620c9ce8dd153637e80">&#9670;&nbsp;</a></span>findOpcode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sfz::findOpcode </td>
          <td>(</td>
          <td class="paramtype">absl::string_view &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::string_view &amp;&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::string_view &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>From a source view, find the next sfz member opcode and its value. </p>
<p>Return them while updating the source by removing this opcode and value from the beginning. The function "consumes" the opcode from the source if one is found.</p>
<p>No check is made to see if the opcode is "valid" in the sfz sense. The output parameters are set only if the method returns true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>A source view; can be updated and shortened </td></tr>
    <tr><td class="paramname">opcode</td><td>An output view on the opcode name </td></tr>
    <tr><td class="paramname">value</td><td>An output view on the opcode value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if an opcode was found </dd>
<dd>
false </dd></dl>

</div>
</div>
<a id="a856b9e5f41439a7443e3fb6e010f8d13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a856b9e5f41439a7443e3fb6e010f8d13">&#9670;&nbsp;</a></span>linearRamp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool SIMD = SIMDConfig::linearRamp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T sfz::linearRamp </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a linear ramp blockwise between 2 values. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the underlying type </td></tr>
    <tr><td class="paramname">SIMD</td><td>use the SIMD version or the scalar version </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>The destination span </td></tr>
    <tr><td class="paramname">start</td><td></td></tr>
    <tr><td class="paramname">step</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T </dd></dl>

</div>
</div>
<a id="adc574b28974cd1bd8af7dee2c2cdb24f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc574b28974cd1bd8af7dee2c2cdb24f">&#9670;&nbsp;</a></span>log()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , bool SIMD = SIMDConfig::mathfuns&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sfz::log </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const Type &gt;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; Type &gt;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Log math function. </p>
<p>The output size will be the minimum of the input span and output span size.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the underlying type </td></tr>
    <tr><td class="paramname">SIMD</td><td>use the SIMD version or the scalar version </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td></td></tr>
    <tr><td class="paramname">output</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af6a4868395156fa7a5cd3a12277e3cab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6a4868395156fa7a5cd3a12277e3cab">&#9670;&nbsp;</a></span>loopingSFZIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool SIMD = SIMDConfig::loopingSFZIndex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float sfz::loopingSFZIndex </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const T &gt;&#160;</td>
          <td class="paramname"><em>jumps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>leftCoeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>rightCoeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; int &gt;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>floatIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>loopEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>loopStart</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an integer index and 2 float coefficients corresponding to the linear interpolation procedure. </p>
<p>This version will loop the index at the upper bound loopend and restart it at the start of the loop.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the underlying type </td></tr>
    <tr><td class="paramname">SIMD</td><td>use the SIMD version or the scalar version </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jumps</td><td>the floating point increments to the index </td></tr>
    <tr><td class="paramname">leftCoeffs</td><td>the linear interpolation coefficients for the left value </td></tr>
    <tr><td class="paramname">rightCoeffs</td><td>the linear interpolation coefficients for the right value </td></tr>
    <tr><td class="paramname">indices</td><td>the integer sample indices for the left values; the right values for interpolation at index i are (indices[i] + 1) and not indices[i+1] </td></tr>
    <tr><td class="paramname">floatIndex</td><td>the starting floating point index </td></tr>
    <tr><td class="paramname">loopEnd</td><td>the end index of the loop </td></tr>
    <tr><td class="paramname">loopStart</td><td>the start index of the loop </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>float </dd></dl>

</div>
</div>
<a id="a699ab4ea2fc4d6179cbd6c4dd9a2f07b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a699ab4ea2fc4d6179cbd6c4dd9a2f07b">&#9670;&nbsp;</a></span>mean()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool SIMD = SIMDConfig::mean&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T sfz::mean </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const T &gt;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the mean of a span. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the underlying type </td></tr>
    <tr><td class="paramname">SIMD</td><td>use the SIMD version or the scalar version </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T </dd></dl>

</div>
</div>
<a id="a4b3086cab227e08d1b22a4e385388127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b3086cab227e08d1b22a4e385388127">&#9670;&nbsp;</a></span>meanSquared()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool SIMD = SIMDConfig::meanSquared&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T sfz::meanSquared </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const T &gt;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the mean squared of a span. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the underlying type </td></tr>
    <tr><td class="paramname">SIMD</td><td>use the SIMD version or the scalar version </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T </dd></dl>

</div>
</div>
<a id="ae9103c48dd4d2a8339524f8f5d4136fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9103c48dd4d2a8339524f8f5d4136fa">&#9670;&nbsp;</a></span>multiplicativeRamp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool SIMD = SIMDConfig::multiplicativeRamp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T sfz::multiplicativeRamp </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a multiplicative ramp blockwise between 2 values. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the underlying type </td></tr>
    <tr><td class="paramname">SIMD</td><td>use the SIMD version or the scalar version </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>The destination span </td></tr>
    <tr><td class="paramname">start</td><td></td></tr>
    <tr><td class="paramname">step</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T </dd></dl>

</div>
</div>
<a id="afc467c5a4f960d8a8afa9516e4020c5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc467c5a4f960d8a8afa9516e4020c5e">&#9670;&nbsp;</a></span>multiplyAdd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool SIMD = SIMDConfig::multiplyAdd&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sfz::multiplyAdd </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const T &gt;&#160;</td>
          <td class="paramname"><em>gain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const T &gt;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a gain to the input and add it on the output. </p>
<p>The output size will be the minimum of the gain span, input span and output span sizes.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the underlying type </td></tr>
    <tr><td class="paramname">SIMD</td><td>use the SIMD version or the scalar version </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gain</td><td></td></tr>
    <tr><td class="paramname">input</td><td></td></tr>
    <tr><td class="paramname">output</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a082ee2dc6715392c07a5f6a5216c537b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a082ee2dc6715392c07a5f6a5216c537b">&#9670;&nbsp;</a></span>normalizeBend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr float sfz::normalizeBend </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>bendValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalize bends between -1 and 1. </p>
<p>We clamp to 8191 instead of 8192 in the low end to have something symmetric with respect to 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bendValue</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>constexpr float </dd></dl>

</div>
</div>
<a id="a9b65015c18e6461f96cb9af4e30cdee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b65015c18e6461f96cb9af4e30cdee8">&#9670;&nbsp;</a></span>normalizeCC()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr float sfz::normalizeCC </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>ccValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalize a CC value between (T)0.0 and (T)1.0. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ccValue</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>constexpr float </dd></dl>

</div>
</div>
<a id="abfcbb9f0d7899c187863d5e457a84fca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfcbb9f0d7899c187863d5e457a84fca">&#9670;&nbsp;</a></span>normalizeNegativePercents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr float sfz::normalizeNegativePercents </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>percentValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalize a possibly negative percentage between -1 and 1. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">percentValue</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>constexpr float </dd></dl>

</div>
</div>
<a id="ac1f49ce61c8d1db977f17efc4ee199bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1f49ce61c8d1db977f17efc4ee199bf">&#9670;&nbsp;</a></span>normalizePercents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr float sfz::normalizePercents </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>percentValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalize a percentage between 0 and 1. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">percentValue</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>constexpr float </dd></dl>

</div>
</div>
<a id="a6fd3f3f2641b8065321f00b8e2e3cbec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fd3f3f2641b8065321f00b8e2e3cbec">&#9670;&nbsp;</a></span>normalizeVelocity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr float sfz::normalizeVelocity </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>velocity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalize a velocity between (T)0.0 and (T)1.0. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ccValue</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>constexpr float </dd></dl>

</div>
</div>
<a id="a3e5453bbc1c786fad5635026eebeaded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e5453bbc1c786fad5635026eebeaded">&#9670;&nbsp;</a></span>pan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool SIMD = SIMDConfig::pan&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sfz::pan </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const T &gt;&#160;</td>
          <td class="paramname"><em>panEnvelope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>leftBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>rightBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pans a mono signal left or right. </p>
<p>The output size will be the minimum of the pan envelope span and left and right buffer span sizes.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the underlying type </td></tr>
    <tr><td class="paramname">SIMD</td><td>use the SIMD version or the scalar version </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">panEnvelope</td><td></td></tr>
    <tr><td class="paramname">leftBuffer</td><td></td></tr>
    <tr><td class="paramname">rightBuffer</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e79b5c1153af2378ddeb5ef1af2e108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e79b5c1153af2378ddeb5ef1af2e108">&#9670;&nbsp;</a></span>readBooleanFromOpcode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">absl::optional&lt;bool&gt; sfz::readBooleanFromOpcode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsfz_1_1_opcode.html">Opcode</a> &amp;&#160;</td>
          <td class="paramname"><em>opcode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a boolean value from the sfz file and cast it to the destination parameter. </p>

</div>
</div>
<a id="a91425402d9ab9ea06c43f2b50deceff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91425402d9ab9ea06c43f2b50deceff7">&#9670;&nbsp;</a></span>readInterleaved()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool SIMD = SIMDConfig::readInterleaved&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sfz::readInterleaved </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const T &gt;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>outputLeft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>outputRight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read interleaved stereo data from a buffer and separate it in a left/right pair of buffers. </p>
<p>The output size will be the minimum of the input span and output spans size.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the underlying type </td></tr>
    <tr><td class="paramname">SIMD</td><td>use the SIMD version or the scalar version </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td></td></tr>
    <tr><td class="paramname">outputLeft</td><td></td></tr>
    <tr><td class="paramname">outputRight</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc410e944cee93f0c4a0cf44279ebe5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc410e944cee93f0c4a0cf44279ebe5d">&#9670;&nbsp;</a></span>readNoteValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">absl::optional&lt;uint8_t&gt; sfz::readNoteValue </td>
          <td>(</td>
          <td class="paramtype">const absl::string_view &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a note in string to its equivalent midi note number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>absl::optional&lt;uint8_t&gt; </dd></dl>

</div>
</div>
<a id="a8d1e1f13e28869bb010ca42494d23ca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d1e1f13e28869bb010ca42494d23ca7">&#9670;&nbsp;</a></span>readOpcode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , std::enable_if_t&lt; std::is_integral&lt; ValueType &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">absl::optional&lt; ValueType &gt; sfz::readOpcode </td>
          <td>(</td>
          <td class="paramtype">absl::string_view&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsfz_1_1_range.html">Range</a>&lt; ValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>validRange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a value from the sfz file and cast it to the destination parameter along with a proper clamping into range if needed. </p>
<p>This particular template version acts on integral target types, but can accept floats as an input.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>the target casting type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the string value to be read and stored </td></tr>
    <tr><td class="paramname">validRange</td><td>the range of admitted values </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>absl::optional&lt;ValueType&gt; the cast value, or null</dd></dl>
<p>This particular template version acts on floating types.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>the target casting type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the string value to be read and stored </td></tr>
    <tr><td class="paramname">validRange</td><td>the range of admitted values </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>absl::optional&lt;ValueType&gt; the cast value, or null </dd></dl>

</div>
</div>
<a id="a3c7883329dc3ff5455577487a444b5e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c7883329dc3ff5455577487a444b5e8">&#9670;&nbsp;</a></span>saturatingSFZIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool SIMD = SIMDConfig::saturatingSFZIndex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float sfz::saturatingSFZIndex </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const T &gt;&#160;</td>
          <td class="paramname"><em>jumps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>leftCoeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>rightCoeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; int &gt;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>floatIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>loopEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes an integer index and 2 float coefficients corresponding to the linear interpolation procedure. </p>
<p>This version will saturate the index to the upper bound if the upper bound is reached.</p>
<p>The indices are computed starting from the given floatIndex, and each increment is given by the elements of jumps. The output size will be the minimum of the inputs span and outputs span size.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the underlying type </td></tr>
    <tr><td class="paramname">SIMD</td><td>use the SIMD version or the scalar version </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jumps</td><td>the floating point increments to the index </td></tr>
    <tr><td class="paramname">leftCoeffs</td><td>the linear interpolation coefficients for the left value </td></tr>
    <tr><td class="paramname">rightCoeffs</td><td>the linear interpolation coefficients for the right value </td></tr>
    <tr><td class="paramname">indices</td><td>the integer sample indices for the left values; the right values for interpolation at index i are (indices[i] + 1) and not indices[i+1] </td></tr>
    <tr><td class="paramname">floatIndex</td><td>the starting floating point index </td></tr>
    <tr><td class="paramname">loopEnd</td><td>the end of the "loop" which is not really a loop because it saturate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>float </dd></dl>

</div>
</div>
<a id="aef36c198066be8bee85b445c483f71a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef36c198066be8bee85b445c483f71a1">&#9670;&nbsp;</a></span>setCCPairFromOpcode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sfz::setCCPairFromOpcode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsfz_1_1_opcode.html">Opcode</a> &amp;&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::optional&lt; CCValuePair &gt; &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsfz_1_1_range.html">Range</a>&lt; ValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>validRange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a CC modulation parameter from an opcode value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opcode</td><td>the source opcode </td></tr>
    <tr><td class="paramname">target</td><td>the new CC modulation parameter </td></tr>
    <tr><td class="paramname">validRange</td><td>the range of admitted values used to clamp the opcode </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38e52ee55b8e40f517f2a43c57931aa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38e52ee55b8e40f517f2a43c57931aa6">&#9670;&nbsp;</a></span>setRangeEndFromOpcode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sfz::setRangeEndFromOpcode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsfz_1_1_opcode.html">Opcode</a> &amp;&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsfz_1_1_range.html">Range</a>&lt; ValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsfz_1_1_range.html">Range</a>&lt; ValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>validRange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a target end of a range from an opcode value, with possibly a textual note rather than a number. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opcode</td><td>the source opcode </td></tr>
    <tr><td class="paramname">target</td><td>the value to update </td></tr>
    <tr><td class="paramname">validRange</td><td>the range of admitted values used to clamp the opcode </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a2f75efbbcdb47c66cf32f18bb207ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a2f75efbbcdb47c66cf32f18bb207ba">&#9670;&nbsp;</a></span>setRangeStartFromOpcode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sfz::setRangeStartFromOpcode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsfz_1_1_opcode.html">Opcode</a> &amp;&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsfz_1_1_range.html">Range</a>&lt; ValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsfz_1_1_range.html">Range</a>&lt; ValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>validRange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a target beginning of a range from an opcode value, with possibly a textual note rather than a number. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opcode</td><td>the source opcode </td></tr>
    <tr><td class="paramname">target</td><td>the value to update </td></tr>
    <tr><td class="paramname">validRange</td><td>the range of admitted values used to clamp the opcode </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83aae00d3fce9c8f65838d7b3a1ee5e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83aae00d3fce9c8f65838d7b3a1ee5e9">&#9670;&nbsp;</a></span>setValueFromOpcode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sfz::setValueFromOpcode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsfz_1_1_opcode.html">Opcode</a> &amp;&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsfz_1_1_range.html">Range</a>&lt; ValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>validRange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a target parameter from an opcode value, with possibly a textual note rather than a number. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opcode</td><td>the source opcode </td></tr>
    <tr><td class="paramname">target</td><td>the value to update </td></tr>
    <tr><td class="paramname">validRange</td><td>the range of admitted values used to clamp the opcode </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a31aeb210ef9bc2aae030c9979a8a2cc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31aeb210ef9bc2aae030c9979a8a2cc0">&#9670;&nbsp;</a></span>setValueFromOpcode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sfz::setValueFromOpcode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsfz_1_1_opcode.html">Opcode</a> &amp;&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::optional&lt; ValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsfz_1_1_range.html">Range</a>&lt; ValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>validRange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a target parameter from an opcode value, with possibly a textual note rather than a number. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opcode</td><td>the source opcode </td></tr>
    <tr><td class="paramname">target</td><td>the value to update </td></tr>
    <tr><td class="paramname">validRange</td><td>the range of admitted values used to clamp the opcode </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a486b854fada90cb158ee8391466d42a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a486b854fada90cb158ee8391466d42a7">&#9670;&nbsp;</a></span>sfzInterpolationCast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool SIMD = SIMDConfig::sfzInterpolationCast&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sfz::sfzInterpolationCast </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const T &gt;&#160;</td>
          <td class="paramname"><em>floatJumps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; int &gt;&#160;</td>
          <td class="paramname"><em>jumps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>leftCoeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>rightCoeffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the linear interpolation coefficients for a floating point index and extracts the integer index of the elements to interpolate. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the underlying type </td></tr>
    <tr><td class="paramname">SIMD</td><td>use the SIMD version or the scalar version </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">floatJumps</td><td>the floating point indices </td></tr>
    <tr><td class="paramname">jumps</td><td>the integer indices outputs </td></tr>
    <tr><td class="paramname">leftCoeffs</td><td>the left interpolation coefficients </td></tr>
    <tr><td class="paramname">rightCoeffs</td><td>the right interpolation coefficients </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a92c69c4723a06f6e692ddfee094420fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92c69c4723a06f6e692ddfee094420fb">&#9670;&nbsp;</a></span>sin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type , bool SIMD = SIMDConfig::mathfuns&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sfz::sin </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const Type &gt;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; Type &gt;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>sin math function </p>
<p>The output size will be the minimum of the input span and output span size.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the underlying type </td></tr>
    <tr><td class="paramname">SIMD</td><td>use the SIMD version or the scalar version </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td></td></tr>
    <tr><td class="paramname">output</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a671c6bbf8866dbeac68ed3b887a705a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a671c6bbf8866dbeac68ed3b887a705a5">&#9670;&nbsp;</a></span>subtract() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool SIMD = SIMDConfig::subtract&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sfz::subtract </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtract a value from a span. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the underlying type </td></tr>
    <tr><td class="paramname">SIMD</td><td>use the SIMD version or the scalar version </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td></td></tr>
    <tr><td class="paramname">output</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb0d4e00d9e7d95051a90753331f2c53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb0d4e00d9e7d95051a90753331f2c53">&#9670;&nbsp;</a></span>subtract() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool SIMD = SIMDConfig::subtract&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sfz::subtract </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const T &gt;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtract a span from another span. </p>
<p>The output size will be the minimum of the input span and output span sizes.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the underlying type </td></tr>
    <tr><td class="paramname">SIMD</td><td>use the SIMD version or the scalar version </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td></td></tr>
    <tr><td class="paramname">output</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a187a894c21d22a6571c6fe2a9394228f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a187a894c21d22a6571c6fe2a9394228f">&#9670;&nbsp;</a></span>writeInterleaved()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool SIMD = SIMDConfig::writeInterleaved&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sfz::writeInterleaved </td>
          <td>(</td>
          <td class="paramtype">absl::Span&lt; const T &gt;&#160;</td>
          <td class="paramname"><em>inputLeft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; const T &gt;&#160;</td>
          <td class="paramname"><em>inputRight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a pair of left and right stereo input into a single buffer interleaved. </p>
<p>The output size will be the minimum of the input spans and output span size.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the underlying type </td></tr>
    <tr><td class="paramname">SIMD</td><td>use the SIMD version or the scalar version </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputLeft</td><td></td></tr>
    <tr><td class="paramname">inputRight</td><td></td></tr>
    <tr><td class="paramname">output</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
			<hr>
			<footer>
				<p style="text-align:left">Copyright &copy; 2019 Paul Ferrand
					<span style="float:right">Generated for sfizz by
						<a href="http://www.doxygen.org/index.html"
							target="_new">Doxygen</a> 1.8.13</span>
				</p>
			</footer>
            </div>
		<script src="./../assets/js/scripts.min.js"></script>
	</body>
</html>
